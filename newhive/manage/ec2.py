import os, subprocess, re, time, paramiko, getpass
import boto
from newhive import config
from newhive import manage
from newhive.manage import aws_credentials
from newhive.utils import memoized, local_date, now
from newhive.utils import friendly_date

try:
    public_hostname = subprocess.check_output(['ec2metadata', '--public-hostname']).strip()
except Exception:
    public_hostname = None

@memoized
def get_ec2_con():
    return boto.connect_ec2(*aws_credentials)

def get_running_webservers():
    reservations = []
    for group_name in ['application', 'dev', 'database']:
        reservations.extend(get_ec2_con().get_all_instances(filters={'instance-state-name': 'running', 'group-name': group_name}))
    return [i for r in reservations for i in r.instances]

def get_instance(name, multi=False):
    instances = filter(lambda i: i.tags.get('Name') == name, get_running_webservers())
    if len(instances) == 0:
        return None
        #raise KeyError("No server named {}".format(name))
    if len(instances) > 1 and not multi:
        raise KeyError("Multiple servers named {}, call with multi=True to return them all".format(name))
    if multi:
        return instances
    else:
        return instances[0]

def get_active_webserver_ids(load_balancer="LoadBalancer2"):
    elb = boto.connect_elb(*aws_credentials)
    return [inst.instance_id for inst in elb.describe_instance_health(load_balancer)]

def get_latest_image(category=None):
    conn = get_ec2_con()
    images = conn.get_all_images(owners=['528729650815'])
    if category:
        images = filter(lambda im: im.tags.get('category') == category, images)
    if not len(images):
        raise ValueError("No newhive AMI with category {}".format(category))
    return sorted(images, key=lambda im: im.tags.get('created', 0), reverse=True)[0]

def image_from_instance(instance_name, no_reboot=True):
    conn = get_ec2_con()
    instance = get_instance(instance_name)
    if len(instance.groups) == 1:
        group = instance.groups[0].name
    else:
        print "Instance belongs to multiple security groups: {}".format([g.name for g in instance.groups])
        group = raw_input("enter category for image: ").strip()

    name = "{group} {date}".format(group=group, date=local_date())
    description = "image generated by newhive.manage.ec2.image_from_instance from server {name} on {date}"
    description = description.format(name=server_name, date=local_date())
    image_id = conn.create_image(instance.id, name, description, no_reboot)
    image = None
    while not image:
        time.sleep(0.5)
        try:
            image = conn.get_image(image_id)
        except conn.ResponseError:
            print "retrying"
            image = None
    image.add_tag('Name',         name       )
    image.add_tag('category',     group      )
    image.add_tag('created',      int(now()) )
    return image

def launch_instance(name, category='dev', git_branch = 'master', **kwargs):
    conn = get_ec2_con()
    image = get_latest_image(category)

    # Default kwargs for run_instance
    run_args = {
            'instance_type': 't1.micro'
            }
    if category in [g.name for g in conn.get_all_security_groups()]:
        run_args.update({'security_groups': [category]})

    # override defaults
    run_args.update(kwargs)

    print "Launching instance with ami: {} and args \n{}".format(image.id, run_args)
    reservation = conn.run_instances(image.id, **run_args)
    instance = reservation.instances[0]

    # Poll for instance startup
    print "\nWhile instance is launching, enter remote login credentials:"
    username = raw_input("username: ")
    password = getpass.getpass("password: ")
    status = instance.update()
    while status == 'pending':
        print "instance status pending"
        time.sleep(5)
        status = instance.update()
    print "instance status {}".format(status)

    print "\nsetting server metadata and name for ec2 console"
    instance.add_tag("Name",         name       )
    instance.add_tag('created',      int(now()) )
    instance.add_tag('terminatable', 'true'     )

    print "adding dns routes for {name}.newhive.com and {name}.newhiveexpression.com".format(name=name)
    manage.route53.add_cname('newhive.com', name, instance.public_dns_name, no_confirmation=True)
    manage.route53.add_cname('tnh.me', name, instance.public_dns_name, no_confirmation=True)

    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    def connect():
        try:
            ssh.connect(instance.public_dns_name, username=username, password=password)
            return True
        except Exception as e:
            return False

    print "\nWaiting 20 seconds for server to startup, then attempting to establish ssh connection"
    time.sleep(20)
    connected = connect()
    while not connected:
        print "retrying ssh connection"
        time.sleep(5)
        connected = connect()

    def remote_exec(command):
        stdin, stdout, stderr = ssh.exec_command(command)
        print "\nRemote Server:"
        for line in stdout:
            print '... ' + line.strip('\n')
        print
        ssh.close()

    command = ";".join([
            'echo',
            'echo "Checking out branch {git_branch}"',
            'cd /var/www/newhive',
            'git fetch',
            'git checkout {git_branch}',
            'git pull origin {git_branch}',
            'echo',
            'echo "setting server name"',
            'sudo /var/www/newhive/bin/set_server_name {name}',
            'echo',
            'echo "restarting apache"',
            'sudo apache2ctl graceful',
        ]).format(git_branch=git_branch, name=name)
    remote_exec(command)

    return instance

def terminate_instance(name):
    instance = get_instance(name)
    if not instance.tags.get('terminatable', '').lower() == 'true':
        print "server tag named 'terminatable' is not set to 'true', not terminating"
        return
    created = instance.tags.get('created')
    fd = friendly_date(int(created)) if created else "an unknown time ago"

    print "Instance ID: {id}  Name: {name}  Groups: {group}  Started: {friendly_date}".format(
        id=instance.id, name=name, group=[g.name for g in instance.groups], friendly_date=fd)
    response = raw_input("Terminate? [yes/NO] ")
    if not response.lower().startswith('y'):
        return
    print "terminating"
    conn = get_ec2_con()
    conn.terminate_instances([instance.id])
